/*
 * HiveMQ REST API
 *
 *  # Introduction  HiveMQ's REST API provides endpoints for the following use cases: - Listing all MQTT Clients - Getting detailed information about a specific MQTT client - Listing all subscriptions for a specific MQTT client - Getting the connection status for a specific MQTT client - Creating and restoring a backup - Starting and stopping a trace recording - Downloading backups and trace recordings  ## API style HiveMQ's API is organized in a [RESTful](http://en.wikipedia.org/wiki/Representational_State_Transfer) fashion.  The API has predictable resource-oriented URLs that consume and return JSON with the content-type `application/json`. It uses standard HTTP response codes and verbs. Some endpoints do return files, those are using the content type `application/octet-stream` or `application/zip`.  The base URL is the Host and configured port of your HiveMQ instances. In most cases it makes sense to configure a reverse-proxy or load balancer to access HiveMQ's REST API.  ## Pagination Some endpoints support returning the results in a paginated fashion. In those cases a cursor can be returned that contains the relative URL for the next page. The desired page size can be specified by using the `limit` query parameter.  Example URL: `http://my-broker-host:8888/api/v1/mqtt/clients?limit=100`  Example Response: ``` {   \"items\": [     {       \"id\": \"client-id-1\"     },      ...      {       \"id\": \"client-id-99\"     }   ],   \"_links\": {     \"next\": \"/api/v1/mqtt/clients?cursor=a-MvelExpd5y0SrXBxDhBvnGmohbpzwGDQFdUyOYWBACqs1TgI4-cUo-A=&limit=100\"   } } ``` To fetch the next page with more results, the URL `http://my-broker-host:8888/api/v1/mqtt/clients?cursor=a-MvelExpd5y0SrXBxDhBvnGmohbpzwGDQFdUyOYWBACqs1TgI4-cUo-A=&limit=100` is called. If the value for `_links.next` is not present, then this is the last page and no further pages are available.  **Note**: If a generated REST API client is used the cursor value must be extracted from the `next URL` and then passed as the cursor in the API call for fetching the next page.  Steps to use pagination in a REST API client: 1. Returned next URL: ``` http://my-broker-host:8888/api/v1/mqtt/clients?cursor=a-MvelExpd5y0SrXBxDhBvnGmohbpzwGDQFdUyOYWBACqs1TgI4-cUo-A=&limit=100 ```  2. Extract the cursor from the next URL: ``` a-MvelExpd5y0SrXBxDhBvnGmohbpzwGDQFdUyOYWBACqs1TgI4-cUo-A= ```  3. Use the cursor in the REST API client to fetch the next page: ``` restClient.mqttClientsGet(pageLimitForRequest, \"a-MvelExpd5y0SrXBxDhBvnGmohbpzwGDQFdUyOYWBACqs1TgI4-cUo-A=\"); ```  ## Errors Conventional HTTP response codes are used to indicate the success or failure of an API request. Codes in the 2xx range generally indicate success. Codes in the 4xx range indicate an error that failed given the information provided (e.g., a required parameter was omitted). Codes in the 5xx range indicate an error on the server side.  For all errors a JSON response with additional details is returned in the format [Problem JSON](https://tools.ietf.org/html/rfc7807).  ## OpenAPI HiveMQ's REST API provides an OpenAPI 3.0 schema definition that can imported into popular API tooling (e.g. Postman) or can be used to generate client-code for multiple programming languages. 
 *
 * The version of the OpenAPI document: 4.21.0
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;

use crate::apis::ResponseContent;
use super::{Error, configuration};

/// struct for passing parameters to the method [`create_trace_recording`]
#[derive(Clone, Debug)]
pub struct CreateTraceRecordingParams {
    /// The trace recording to create
    pub trace_recording_item: Option<crate::models::TraceRecordingItem>
}

/// struct for passing parameters to the method [`delete_trace_recording`]
#[derive(Clone, Debug)]
pub struct DeleteTraceRecordingParams {
    /// The name of the trace recording to delete.
    pub trace_recording_id: String
}

/// struct for passing parameters to the method [`download_trace_recording_file`]
#[derive(Clone, Debug)]
pub struct DownloadTraceRecordingFileParams {
    /// The id of the trace recording.
    pub trace_recording_id: String
}

/// struct for passing parameters to the method [`stop_trace_recording`]
#[derive(Clone, Debug)]
pub struct StopTraceRecordingParams {
    /// The name of the trace recording to patch/stop.
    pub trace_recording_id: String,
    /// The trace recording to change
    pub trace_recording_item: Option<crate::models::TraceRecordingItem>
}


/// struct for typed errors of method [`create_trace_recording`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateTraceRecordingError {
    Status400(crate::models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`delete_trace_recording`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DeleteTraceRecordingError {
    Status400(crate::models::Errors),
    Status404(crate::models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`download_trace_recording_file`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum DownloadTraceRecordingFileError {
    Status400(crate::models::Errors),
    Status404(crate::models::Errors),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_all_trace_recordings`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAllTraceRecordingsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`stop_trace_recording`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum StopTraceRecordingError {
    Status400(crate::models::Errors),
    Status404(crate::models::Errors),
    UnknownValue(serde_json::Value),
}


/// Creates a new trace recording.    To create a trace recording you must specify a name, start date, end date, a set of filters and the desired packets that should be traced.  At least one client or topic filter and at least one packet is required to create a trace recording.  The client and topic filters can be [regular expressions](https://www.hivemq.com/docs/hivemq/4.3/control-center/analytic.html#regular-expressions).
pub async fn create_trace_recording(configuration: &configuration::Configuration, params: CreateTraceRecordingParams) -> Result<crate::models::TraceRecordingItem, Error<CreateTraceRecordingError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let trace_recording_item = params.trace_recording_item;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/v1/management/trace-recordings", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::POST, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&trace_recording_item);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<CreateTraceRecordingError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Deletes an existing trace recording.    
pub async fn delete_trace_recording(configuration: &configuration::Configuration, params: DeleteTraceRecordingParams) -> Result<(), Error<DeleteTraceRecordingError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let trace_recording_id = params.trace_recording_id;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/v1/management/trace-recordings/{traceRecordingId}", local_var_configuration.base_path, traceRecordingId=crate::apis::urlencode(trace_recording_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::DELETE, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        Ok(())
    } else {
        let local_var_entity: Option<DeleteTraceRecordingError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Download a specific trace recording.    This endpoint returns the content of the trace recording with the content-type `application/zip`.   Only trace recordings in the states `IN_PROGRESS`, `STOPPED` and `ABORTED` can be downloaded.
pub async fn download_trace_recording_file(configuration: &configuration::Configuration, params: DownloadTraceRecordingFileParams) -> Result<std::path::PathBuf, Error<DownloadTraceRecordingFileError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let trace_recording_id = params.trace_recording_id;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/v1/management/files/trace-recordings/{traceRecordingId}", local_var_configuration.base_path, traceRecordingId=crate::apis::urlencode(trace_recording_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<DownloadTraceRecordingFileError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Lists all known trace recordings.   Trace recordings can be in different states. These states are: - `SCHEDULED` if the start date for a trace recording is in the future - `STOPPED` if a trace recording has reached its end date or was stopped manually - `IN_PROGRESS` when the trace recording is currently ongoing - `ABORTED` if the trace recording was aborted by the server 
pub async fn get_all_trace_recordings(configuration: &configuration::Configuration) -> Result<crate::models::TraceRecordingList, Error<GetAllTraceRecordingsError>> {
    let local_var_configuration = configuration;

    // unbox the parameters


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/v1/management/trace-recordings", local_var_configuration.base_path);
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::GET, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<GetAllTraceRecordingsError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

/// Stops an existing trace recording.  Only the state of the trace recording can be set to `STOPPED` with this endpoint, changes to other fields are ignored.
pub async fn stop_trace_recording(configuration: &configuration::Configuration, params: StopTraceRecordingParams) -> Result<crate::models::TraceRecordingItem, Error<StopTraceRecordingError>> {
    let local_var_configuration = configuration;

    // unbox the parameters
    let trace_recording_id = params.trace_recording_id;
    let trace_recording_item = params.trace_recording_item;


    let local_var_client = &local_var_configuration.client;

    let local_var_uri_str = format!("{}/api/v1/management/trace-recordings/{traceRecordingId}", local_var_configuration.base_path, traceRecordingId=crate::apis::urlencode(trace_recording_id));
    let mut local_var_req_builder = local_var_client.request(reqwest::Method::PATCH, local_var_uri_str.as_str());

    if let Some(ref local_var_user_agent) = local_var_configuration.user_agent {
        local_var_req_builder = local_var_req_builder.header(reqwest::header::USER_AGENT, local_var_user_agent.clone());
    }
    local_var_req_builder = local_var_req_builder.json(&trace_recording_item);

    let local_var_req = local_var_req_builder.build()?;
    let local_var_resp = local_var_client.execute(local_var_req).await?;

    let local_var_status = local_var_resp.status();
    let local_var_content = local_var_resp.text().await?;

    if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
        serde_json::from_str(&local_var_content).map_err(Error::from)
    } else {
        let local_var_entity: Option<StopTraceRecordingError> = serde_json::from_str(&local_var_content).ok();
        let local_var_error = ResponseContent { status: local_var_status, content: local_var_content, entity: local_var_entity };
        Err(Error::ResponseError(local_var_error))
    }
}

